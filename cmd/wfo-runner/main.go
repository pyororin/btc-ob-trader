package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"gopkg.in/yaml.v3"
)

// --- Configuration Structs ---

// WFORunnerConfig matches the `wfo_runner` section in the YAML file.
type WFORunnerConfig struct {
	StartDate      string `yaml:"start_date"`
	EndDate        string `yaml:"end_date"`
	IsWindowDays   int    `yaml:"is_window_days"`
	OosWindowDays  int    `yaml:"oos_window_days"`
	StepDays       int    `yaml:"step_days"`
}

// OptimizerConfig is the top-level structure for the YAML config file.
type OptimizerConfig struct {
	WFORunner WFORunnerConfig `yaml:"wfo_runner"`
	NTrials   int             `yaml:"n_trials"`
}

// --- Cycle and Result Structs ---

// WFOCycle defines the time windows for a single walk-forward cycle.
type WFOCycle struct {
	ID         string
	IsStart    time.Time
	IsEnd      time.Time
	OosEnd     time.Time
}

// CycleResult maps to the summary.json file generated by the Python script.
type CycleResult struct {
	CycleID      string                 `json:"cycle_id"`
	Status       string                 `json:"status"`
	Reason       string                 `json:"reason"`
	BestParams   map[string]interface{} `json:"best_params"`
	ParamSource  string                 `json:"param_source"`
	ISMetrics    map[string]interface{} `json:"is_metrics"`
	OOSMetrics   map[string]interface{} `json:"oos_metrics"`
}

// --- Main Application ---

func main() {
	log.Println("--- Starting Walk-Forward Optimization (WFO) Runner ---")

	// 1. Load Configuration
	cfg, err := loadConfig("config/optimizer_config.yaml")
	if err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// 2. Generate WFO Cycles
	cycles, err := generateWFOCycles(cfg.WFORunner)
	if err != nil {
		log.Fatalf("Failed to generate WFO cycles: %v", err)
	}
	log.Printf("Generated %d WFO cycles to run.", len(cycles))

	// 3. Setup Database Connection
	dbpool, err := setupDatabaseConnection()
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer dbpool.Close()

	// 4. Execute Cycles
	for _, cycle := range cycles {
		log.Printf("--- Executing Cycle: %s ---", cycle.ID)
		log.Printf("IS Window: %s -> %s", cycle.IsStart.Format(time.RFC3339), cycle.IsEnd.Format(time.RFC3339))
		log.Printf("OOS Window: %s -> %s", cycle.IsEnd.Format(time.RFC3339), cycle.OosEnd.Format(time.RFC3339))

		err := executeCycle(cycle, cfg.NTrials)
		if err != nil {
			log.Printf("ERROR: Cycle %s failed: %v", cycle.ID, err)
			// Even if the python script fails, it should create a summary.json.
			// We try to read and record it.
		}

		// Read result and save to DB
		result, err := readCycleResult(cycle.ID)
		if err != nil {
			log.Printf("ERROR: Could not read result for cycle %s: %v", cycle.ID, err)
			continue
		}

		err = insertCycleResult(dbpool, result, cycle)
		if err != nil {
			log.Printf("ERROR: Could not insert result for cycle %s into DB: %v", cycle.ID, err)
		} else {
			log.Printf("Successfully recorded result for cycle %s.", cycle.ID)
		}
	}

	log.Println("--- WFO Runner Finished ---")
}

func loadConfig(path string) (*OptimizerConfig, error) {
	configBytes, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("could not read config file at %s: %w", path, err)
	}

	var cfg OptimizerConfig
	err = yaml.Unmarshal(configBytes, &cfg)
	if err != nil {
		return nil, fmt.Errorf("could not parse YAML config: %w", err)
	}
	return &cfg, nil
}

func generateWFOCycles(cfg WFORunnerConfig) ([]WFOCycle, error) {
	startDate, err := time.Parse(time.RFC3339, cfg.StartDate)
	if err != nil {
		return nil, fmt.Errorf("invalid start_date: %w", err)
	}
	endDate, err := time.Parse(time.RFC3339, cfg.EndDate)
	if err != nil {
		return nil, fmt.Errorf("invalid end_date: %w", err)
	}

	var cycles []WFOCycle
	isDuration := time.Duration(cfg.IsWindowDays) * 24 * time.Hour
	oosDuration := time.Duration(cfg.OosWindowDays) * 24 * time.Hour
	stepDuration := time.Duration(cfg.StepDays) * 24 * time.Hour

	cycleStart := startDate
	cycleCount := 1
	for {
		isEnd := cycleStart.Add(isDuration)
		oosEnd := isEnd.Add(oosDuration)

		if oosEnd.After(endDate) {
			break
		}

		cycles = append(cycles, WFOCycle{
			ID:      fmt.Sprintf("cycle-%02d", cycleCount),
			IsStart: cycleStart,
			IsEnd:   isEnd,
			OosEnd:  oosEnd,
		})

		cycleStart = cycleStart.Add(stepDuration)
		cycleCount++
	}
	return cycles, nil
}

func executeCycle(cycle WFOCycle, nTrials int) error {
	// The Python script needs time in 'YYYY-MM-DD HH:MM:SS' format
	const timeFmt = "2006-01-02 15:04:05"

	cmd := exec.Command("python3", "-m", "optimizer.main",
		"--is-start-time", cycle.IsStart.Format(timeFmt),
		"--is-end-time", cycle.IsEnd.Format(timeFmt),
		"--oos-end-time", cycle.OosEnd.Format(timeFmt),
		"--cycle-id", cycle.ID,
		"--n-trials", fmt.Sprintf("%d", nTrials),
	)

	// Set the working directory for the python script relative to the Go binary
	cmd.Dir = "../../" // Run from the repo root

	// Capture output for logging
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("Python script execution failed for cycle %s. Output:\n%s", cycle.ID, string(output))
		return fmt.Errorf("python optimizer script failed: %w", err)
	}

	log.Printf("Python script for cycle %s finished successfully. Output:\n%s", cycle.ID, string(output))
	return nil
}

func readCycleResult(cycleID string) (*CycleResult, error) {
	// Path is relative to the repo root where the runner is executed
	resultPath := filepath.Join("data/wfo_results", cycleID, "summary.json")

	jsonBytes, err := ioutil.ReadFile(resultPath)
	if err != nil {
		return nil, fmt.Errorf("could not read summary.json at %s: %w", resultPath, err)
	}

	var result CycleResult
	err = json.Unmarshal(jsonBytes, &result)
	if err != nil {
		return nil, fmt.Errorf("could not parse summary.json: %w", err)
	}
	return &result, nil
}

func setupDatabaseConnection() (*pgxpool.Pool, error) {
	// Using environment variables for DB connection is standard and secure
	dbUser := os.Getenv("DB_USER")
	dbPassword := os.Getenv("DB_PASSWORD")
	dbHost := os.Getenv("DB_HOST")
	dbPort := os.Getenv("DB_PORT")
	dbName := os.Getenv("DB_NAME")

	if dbUser == "" || dbPassword == "" || dbHost == "" || dbPort == "" || dbName == "" {
		return nil, fmt.Errorf("database environment variables (DB_USER, DB_PASSWORD, etc.) are not fully set")
	}

	connStr := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		dbUser, dbPassword, dbHost, dbPort, dbName)

	dbpool, err := pgxpool.New(context.Background(), connStr)
	if err != nil {
		return nil, fmt.Errorf("unable to connect to database: %w", err)
	}
	return dbpool, nil
}

func insertCycleResult(db *pgxpool.Pool, result *CycleResult, cycle WFOCycle) error {
	paramsJSON, err := json.Marshal(result.BestParams)
	if err != nil {
		return fmt.Errorf("failed to marshal best_params to JSON: %w", err)
	}

	// Helper to safely get metric values as nullable types
	getMetric := func(metrics map[string]interface{}, key string) interface{} {
		if val, ok := metrics[key]; ok {
			return val
		}
		return nil
	}

	isMetrics := result.ISMetrics
	oosMetrics := result.OOSMetrics

	query := `
        INSERT INTO wfo_results (
            cycle_id, status, reason, is_start_time, is_end_time, oos_end_time,
            is_sharpe_ratio, is_profit_factor, is_max_drawdown, is_relative_drawdown, is_trades, is_win_rate, is_sqn,
            oos_sharpe_ratio, oos_profit_factor, oos_max_drawdown, oos_trades, oos_win_rate,
            best_params, param_source, created_at, updated_at
        ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, NOW(), NOW()
        )
        ON CONFLICT (cycle_id) DO UPDATE SET
            status = EXCLUDED.status,
            reason = EXCLUDED.reason,
            is_sharpe_ratio = EXCLUDED.is_sharpe_ratio,
            oos_sharpe_ratio = EXCLUDED.oos_sharpe_ratio,
            best_params = EXCLUDED.best_params,
            updated_at = NOW();
    `
	_, err = db.Exec(context.Background(), query,
		result.CycleID,
		result.Status,
		sql.NullString{String: result.Reason, Valid: result.Reason != ""},
		cycle.IsStart,
		cycle.IsEnd,
		cycle.OosEnd,
		getMetric(isMetrics, "sharpe_ratio"),
		getMetric(isMetrics, "profit_factor"),
		getMetric(isMetrics, "max_drawdown"),
		getMetric(isMetrics, "relative_drawdown"),
		getMetric(isMetrics, "trades"),
		getMetric(isMetrics, "win_rate"),
		getMetric(isMetrics, "sqn"),
		getMetric(oosMetrics, "SharpeRatio"),
		getMetric(oosMetrics, "ProfitFactor"),
		getMetric(oosMetrics, "MaxDrawdown"),
		getMetric(oosMetrics, "TotalTrades"),
		getMetric(oosMetrics, "WinRate"),
		paramsJSON,
		sql.NullString{String: result.ParamSource, Valid: result.ParamSource != ""},
	)

	return err
}
