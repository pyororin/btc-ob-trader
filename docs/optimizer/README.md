# `optimizer` サービス 詳細設計書

## 1. サービスの概要

`optimizer`サービスは、取引戦略のパラメータを自動的に最適化する心臓部です。Python製の最適化フレームワーク`Optuna`を利用して、過去の市場データに対するバックテストを数千回繰り返し、最も収益性が高く、かつ頑健（ロバスト）なパラメータの組み合わせを発見します。

このサービスは、独立した`drift-monitor`サービスから最適化要求を受け、`main.py`をエントリーポイントとして最適化プロセスを実行します。

最終的に見つけ出した最適なパラメータ設定を`trade_config.yaml`ファイルとして出力し、`bot`サービスが実際の取引で利用できるようにします。

## 2. モジュール構成

`optimizer`サービスは、責務に基づいて複数のモジュールに分割されています。

> [!NOTE]
> パフォーマンス監視を行う `drift-monitor` は、別のサービスとして定義されています。詳細はそちらの設計書を参照してください。

- `main.py`: `optimizer`サービスのメインエントリーポイント。`drift-monitor`によって作成されたジョブファイルを監視し、最適化プロセス全体を管理する。
- `config.py`: `optimizer_config.yaml`から設定を読み込み、サービス全体で利用する定数やパラメータ（DB接続情報、各種閾値など）を一元管理する。
- `data.py`: `timescaledb`からのデータエクスポート、および最適化に使用するIn-Sample (IS)データと検証用のOut-of-Sample (OOS)データへの分割を担当する。
- `simulation.py`: Go言語で実装されたバックテストエンジン（`cmd/bot/main.go --simulate`）をサブプロセスとして呼び出し、特定のパラメータセットでのシミュレーションを実行する。
- `objective.py`: Optunaの`Trial`ごとに実行される目的関数を定義する。パラメータの提案、シミュレーションの実行、評価指標（シャープレシオ、ドローダウン等）の計算、および枝刈り（Pruning）ロジックを含む。
- `study.py`: Optunaの`Study`オブジェクトの作成、最適化の実行、完了後の結果分析（複合スコアでの再評価）、そしてOOS検証までの一連のフローを管理する。
- `analyzer.py`: 最適化で得られた多数の良好な結果から、KDE（カーネル密度推定）を用いてパラメータの分布を分析し、単一の最良値ではなく、最も安定した（頑健な）パラメータ領域を特定する。

## 3. Docker Compose上の役割と設定

`docker-compose.yml`では、`optimizer`サービスが定義されます。

```yaml
services:
  optimizer:
    build:
      context: .
      dockerfile: optimizer/Dockerfile
    container_name: obi-scalp-optimizer
    # main.py を実行
    command: python -m optimizer.main
    healthcheck:
      test: ["CMD-SHELL", "test -f /data/params/trade_config.yaml"]
      # ...
    restart: always
    # ...
```

-   **`optimizer`サービス**: `main.py`を起動し、`drift-monitor`サービスによって生成される最適化ジョブの発生を待ちます。`healthcheck`は最適化成功の証である`trade_config.yaml`の存在を確認し、`bot`サービスの起動条件となります。

## 4. 処理フロー

### 4.1. 最適化の実行 (`main.py` と関連モジュール)

1.  **起動と事前コンパイル**: `main.py`は、サービスの起動時に、まずGo言語で書かれたバックテストエンジン（`cmd/bot/main.go`）を一度だけコンパイルし、実行可能バイナリ（`/app/bin/bot`）を生成します。これにより、最適化の各試行で毎回コンパイルするオーバーヘッドをなくし、処理速度を大幅に向上させます。
2.  **ジョブの待機**: `main.py`は、`drift-monitor`サービスによって`optimization_job.json`が作成されるのを待ち続けます。
3.  **データ準備 (`data.py`)**:
    -   `go run cmd/export/main.go`を実行し、ジョブで指定された期間の市場データをCSVにエクスポートします。
    -   データをIn-Sample (IS)とOut-of-Sample (OOS)に分割します。
4.  **In-Sample (IS) 最適化 (`study.py`, `objective.py`)**:
    -   `study.py`がOptunaの`Study`を新規作成します。
    -   設定された`n_trials`回数、`objective.py`の目的関数が呼び出されます。
    -   目的関数は、`trial.suggest_*`でパラメータを生成し、`simulation.py`経由でバックテストを実行し、結果を評価します。性能の悪い試行は枝刈りされます。
4.  **結果分析と候補選定 (`study.py`, `analyzer.py`)**:
    -   **複合スコアによる再評価**: Optunaの最適化は単一の目的関数（例：シャープレシオ）を最大化するように進められますが、最終的なパラメータ選定では、ドローダウン、勝率、取引回数など複数の指標を総合的に評価することが望ましいです。`study.py`では、全試行完了後にこれらの複数指標を正規化し、重み付けした「複合スコア」を計算して、全試行を再ランク付けします。これにより、単一指標では見逃される可能性のある、よりバランスの取れたパラメータ候補を発見します。
    -   **パラメータの頑健性分析 (KDE)**: 最高のスコアを記録した単一のパラメータセットは、特定の期間に過剰適合（カーブフィッティング）している可能性があります。`analyzer.py`では、複合スコア上位の試行群（例：上位10%）が持つパラメータの分布を分析します。具体的には、カーネル密度推定（KDE）を用いて、各パラメータがどのような値に集中しているかを可視化・数値化します。この分析により、偶然見つかった一点の「PEAK（最高点）」ではなく、性能の良いパラメータが密集している「PLATEAU（高原）」を特定し、その中心値を最も頑健なパラメータとして選定します。
5.  **Out-of-Sample (OOS) 検証 (`study.py`)**:
    -   IS最適化で選ばれた候補（頑健パラメータ、IS上位パラメータ）を、未知のOOSデータで検証します。
    -   OOSでの結果が設定された最低基準を満たせば「合格」です。
    -   合格した場合はそのパラメータを`trade_config.yaml`として保存し、プロセスを正常終了します。
    -   不合格だった場合は、次の候補でOOS検証を試みます（`max_retry`回まで）。
6.  **完了と待機**: `optimization_job.json`を削除し、次のジョブを待ちます。

## 5. 設計思想と考慮点

-   **責務の明確化**: `optimizer`サービスはパラメータ最適化の計算処理に特化しています。パフォーマンス監視や最適化のトリガーは外部の`drift-monitor`サービスが担当することで、各サービスが単一責任の原則に従うように設計されています。
-   **モジュール化**: `optimizer`内のロジックを機能ごとにファイル分割することで、コードの可読性、保守性、テスト容易性を向上させています。
-   **自動化されたWalk-Forward最適化**: 「学習(IS)」と「検証(OOS)」を分離するウォークフォワード分析を自動化し、カーブフィッティングを抑制します。
-   **頑健性の重視**: 単一の最高スコアだけでなく、複合スコアやパラメータ分布の分析を通じて、より信頼性の高いパラメータを選択します。
-   **効率的な探索**: Optunaの高度な探索アルゴリズムを利用することで、広大なパラメータ空間から効率的に最適解を発見します。
