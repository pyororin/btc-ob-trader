# `optimizer` サービス 詳細設計書

## 1. サービスの概要

`optimizer`は、取引戦略のパラメータを自動的に最適化するためのコンポーネント群です。
本番稼働中のパフォーマンス劣化を監視し、軽微なパラメータ調整を自動で行うプロセスです。
`drift-monitor`サービスがパフォーマンス低下を検知すると、`optimizer`サービスをトリガーし、直近のデータで小規模な最適化を実行して`trade_config.yaml`を更新します。

## 2. アーキテクチャと処理フロー

### Drift-Monitorによる継続的最適化の処理フロー

これは本番稼働中の自動調整プロセスです。パフォーマンスの劣化を検知すると、単純なIS/OOS最適化ではなく、より堅牢な**ウォークフォワード分析 (WFA)** を実行してパラメータの有効性を検証します。

1.  **ドリフト検知**: `drift-monitor`が`pnl_summary`テーブルを監視し、パフォーマンス低下（シャープレシオの悪化など）を検知します。
2.  **ジョブ発行**: `optimization_job.json`ファイルを`/data/params`に作成します。
3.  **ウォークフォワード分析の実行**: `optimizer`サービスがジョブファイルを検知し、静的な単一分割ではなく、**ウォークフォワード分析 (`walk_forward.py`)** を開始します。
    -   直近のデータ（例: 過去30日間）を、複数の連続した学習(Train)フェーズと検証(Validate)フェーズに分割します（例: 5スプリット）。
    -   各スプリットで「学習→検証」を繰り返し、パラメータセットの堅牢性を評価します。
4.  **設定更新**: WFA全体の成功率が設定された閾値（例: `min_success_ratio: 0.6`）を上回った場合にのみ、最新の成功したスプリットから得られた最良パラメータを`/data/params/trade_config.yaml`に保存します。これにより、一時的な市場状況に過剰適合した不安定なパラメータが本番環境に適用されるリスクを大幅に低減します。稼働中の`bot`サービスは、更新されたファイルを自動でリロードします。

## 3. モジュール構成

-   `optimizer/main.py`: ファイル監視ループも含む。
-   `optimizer/study.py`: 1サイクル分のOptuna最適化（IS最適化とOOS検証）を実行し、結果を返す。
-   `optimizer/data.py`: 指定された時間枠のデータをエクスポートし、IS/OOSに分割する。
-   `optimizer/config.py`: `optimizer_config.yaml`から設定を読み込む。
-   `simulation.py`: Goのバックテストエンジンをサブプロセスとして呼び出す。
-   `objective.py`: Optunaの目的関数を定義する。

## 4. 実行方法

### 継続的最適化の実行

`drift-monitor`と`optimizer`サービスは、`make up`でbotと共に自動的に起動します。手動で単発の最適化をトリガーする場合は、従来通り`make optimize`を使用できます。

## 5. 設計思想と考慮点

-   **堅牢性の徹底検証**: 単一のIS/OOS分割ではなく、多数のサイクルを連続して実行することで、パラメータが過剰適合していないかを徹底的に検証します。
-   **結果の永続化**: 全サイクルの結果をデータベースに保存することで、将来的な分析やレポーティングが容易になります。これにより、戦略の経時的なパフォーマンス変化や弱点を特定できます。
