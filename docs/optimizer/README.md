# `optimizer` サービス 詳細設計書

## 1. サービスの概要

`optimizer`は、取引戦略のパラメータを自動的に最適化するためのコンポーネント群です。主に2つの機能を提供します。

1.  **Walk-Forward Optimization (WFO) Runner**:
    -   システムの堅牢性を評価するための、大規模なウォークフォワード最適化を実行します。
    -   Go言語で実装されたオーケストレーター (`wfo-runner`) が、長期間のデータを複数の「サイクル」に分割し、各サイクルでIS（In-Sample）最適化とOOS（Out-of-Sample）検証を繰り返します。
    -   このプロセスにより、特定の期間だけでなく、様々な市場状況で安定して機能する戦略を見つけ出すことを目的とします。
    -   実行は `make run-wfo` コマンドで行い、結果は`wfo_results`テーブルに保存されます。

2.  **Drift-Monitorによる継続的最適化**:
    -   本番稼働中のパフォーマンス劣化を監視し、軽微なパラメータ調整を自動で行う旧来のプロセスです。
    -   `drift-monitor`サービスがパフォーマンス低下を検知すると、`optimizer`サービスをトリガーし、直近のデータで小規模な最適化を実行して`trade_config.yaml`を更新します。

## 2. アーキテクチャと処理フロー

### 2.1. Walk-Forward Optimization (WFO) の処理フロー

WFOは、過学習（カーブフィッティング）を避け、パラメータの頑健性を検証するための最も重要なプロセスです。`make run-wfo` を実行すると、以下のフローが開始されます。

1.  **Go製 WFO Runnerの起動 (`cmd/wfo-runner`)**:
    -   `wfo-runner`が起動し、`config/optimizer_config.yaml`内の`wfo_runner`セクションから設定（分析期間、IS/OOSウィンドウサイズ等）を読み込みます。
    -   設定に基づき、全分析期間を複数の連続した`WFOCycle`（例：サイクル1 = 1月-3月で学習、4月で検証）に分割します。

2.  **各サイクルの実行 (ループ)**:
    -   Runnerは各サイクルを順番に処理します。
    -   **Pythonオプティマイザの実行**: GoのRunnerは、サイクルの時間枠（IS開始、IS終了、OOS終了）とサイクルIDを引数として、Pythonオプティマイザ (`optimizer.main`) をサブプロセスとして呼び出します。
    -   **データ準備 (`data.py`)**: Pythonスクリプトは指定された期間のデータをDBからエクスポートし、ISデータとOOSデータに分割します。各サイクルのデータと結果は、`/data/wfo_results/{cycle-id}/` に隔離されます。
    -   **IS最適化 (`study.py`)**: Optunaを使い、ISデータのみでパラメータ最適化を実行します。
    -   **OOS検証 (`study.py`)**: ISで最も良かったパラメータをOOSデータで検証します。
    -   **結果の保存**: Pythonスクリプトは、サイクルの結果（IS/OOSのパフォーマンス指標、最適なパラメータ等）を`summary.json`としてサイクル固有のディレクトリに保存します。

3.  **結果の集計**:
    -   GoのRunnerは、`summary.json`を読み取り、その内容を`wfo_results`データベーステーブルに書き込みます。
    -   全サイクルが完了すると、`wfo_results`テーブルには各期間における戦略のパフォーマンスが記録され、全体的な堅牢性の評価が可能になります。

### 2.2. Drift-Monitorによる継続的最適化の処理フロー

これは本番稼働中の自動調整プロセスです。

1.  **ドリフト検知**: `drift-monitor`が`pnl_summary`テーブルを監視し、パフォーマンス低下（シャープレシオの悪化など）を検知します。
2.  **ジョブ発行**: `optimization_job.json`ファイルを`/data/params`に作成します。
3.  **最適化実行**: `optimizer`サービス（`optimizer.main`の旧ループモード）がジョブファイルを検知し、直近データで単一のIS/OOS最適化を実行します。
4.  **設定更新**: OOS検証に合格したパラメータを`/data/params/trade_config.yaml`に保存します。稼働中の`bot`サービスはこれを自動でリロードします。

## 3. モジュール構成

-   `cmd/wfo-runner/main.go`: WFOのオーケストレーションを担当するGoアプリケーション。
-   `optimizer/main.py`: WFOサイクルを実行するためのコマンドラインインターフェースを持つPythonスクリプト。旧来のファイル監視ループも含む。
-   `optimizer/study.py`: 1サイクル分のOptuna最適化（IS最適化とOOS検証）を実行し、結果を返す。
-   `optimizer/data.py`: 指定された時間枠のデータをエクスポートし、IS/OOSに分割する。
-   `optimizer/config.py`: `optimizer_config.yaml`から設定を読み込む。
-   `simulation.py`: Goのバックテストエンジンをサブプロセスとして呼び出す。
-   `objective.py`: Optunaの目的関数を定義する。

## 4. データベース

### `wfo_results` テーブル

WFOの各サイクルの結果を格納するために、新たに`wfo_results`テーブルが追加されました。

-   **役割**: 各サイクル（特定のIS/OOS期間）のパフォーマンス指標と、そのサイクルで見つかった最適なパラメータを記録します。
-   **主なカラム**:
    -   `cycle_id`: "cycle-01", "cycle-02"などの一意なID。
    -   `status`: サイクルの成功・失敗ステータス。
    -   `is_start_time`, `is_end_time`, `oos_end_time`: サイクルの期間。
    -   `is_*`, `oos_*`: ISとOOSそれぞれのパフォーマンス指標（Sharpe Ratio, Profit Factor, tradesなど）。
    -   `best_params`: OOS検証に合格したパラメータのJSON。
-   **目的**: このテーブルを分析することで、どのパラメータが様々な市場状況で安定して機能するか、また戦略がどのような市場で得意/不得意かを知ることができます。

## 5. 実行方法

### Walk-Forward Optimizationの実行

大規模なWFO分析を実行するには、以下のコマンドを使用します。

```bash
make run-wfo
```

-   このコマンドは`wfo-runner`サービスを起動します。
-   処理には非常に長い時間がかかることがあります。
-   実行中は、各サイクルのログがコンソールに出力されます。
-   完了後、全結果は`wfo_results`テーブルに格納されます。

### 継続的最適化の実行

`drift-monitor`と`optimizer`サービスは、`make up`でbotと共に自動的に起動します。手動で単発の最適化をトリガーする場合は、従来通り`make optimize`を使用できます。

## 6. 設計思想と考慮点

-   **責務の分離**: WFOの複雑なオーケストレーションはGoの`wfo-runner`が担当し、単一サイクルの数学的な最適化はPython/Optunaが担当するという、言語の得意分野を活かした責務分離を行っています。
-   **堅牢性の徹底検証**: 単一のIS/OOS分割ではなく、多数のサイクルを連続して実行することで、パラメータが過剰適合していないかを徹底的に検証します。
-   **結果の永続化**: 全サイクルの結果をデータベースに保存することで、将来的な分析やレポーティングが容易になります。これにより、戦略の経時的なパフォーマンス変化や弱点を特定できます。

## 7. パラメータチューニングの指針 (Parameter Tuning Guidelines)

### 7.1. IS (In-Sample) オーバーフィッティング問題への対処

ログ分析の結果、IS期間で高いパフォーマンスを示したパラメータがOOS (Out-of-Sample) 期間では全く機能しない（取引回数0回など）、典型的なオーバーフィッティング（過学習）の問題が確認されました。これは、最適化プロセスがISデータ特有のノイズまで学習してしまい、未知のデータに対する汎用性を失っていることを示唆します。

この問題に対処するため、以下の3つのアプローチで設定を調整しました。

### 7.2. パラメータ探索範囲の調整 (`optimizer/objective.py`)

より頑健で、多様な市場状況に対応できるパラメータを発見するため、探索範囲を以下のように調整しました。

-   **モデルの単純化**:
    -   `dynamic_obi_enabled`: `False`に固定。ボラティリティに応じた動的な閾値調整機能を無効化し、モデルの複雑さを低減。これにより、オーバーフィッティングのリスクを下げます。
-   **探索範囲の拡大**:
    -   `spread_limit`: `20-80` から `20-150` に拡大。取引機会を増やす方向で探索。
    -   `long_tp`, `short_tp`: `50-200` から `50-400` に拡大。より大きな利益幅を許容。
    -   `long_sl`, `short_sl`: `-200, -50` から `-400, -50` に拡大。より大きな損失許容度を探索。
-   **シグナル閾値の引き上げ**:
    -   `composite_threshold`: `0.1-0.5` から `0.25-0.75` に引き上げ。より確度の高いシグナルでのみエントリーするようにし、ノイズによる誤シグナルを抑制。

### 7.3. 目的関数の重み調整 (`config/optimizer_config.yaml`)

最適化の目標を、単なる高収益から「リスク調整後の安定した収益」へとシフトさせるため、目的関数の重みを変更しました。

-   `sharpe_ratio`: `1.0` -> `2.0` (重要度を倍増)
-   `profit_factor`: `1.0` -> `0.5` (重要度を半減)
-   `trades`: `0.5` -> `0.25` (重要度を半減)

これにより、リスクあたりのリターンが高い、より安定したパラメータセットが選ばれやすくなります。

### 7.4. 安定性分析の強化 (`config/optimizer_config.yaml`)

パラメータのわずかな変動に対する性能の安定度（頑健性）をより厳しく評価するため、ペナルティ係数を引き上げました。

-   `penalty_factor`: `0.75` -> `1.5`

これにより、パラメータの微小な変化でパフォーマンスが大きく劣化するような、ピーキーで信頼性の低い解が選ばれにくくなります。
